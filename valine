#!/bin/bash
# valine v0.7.4 last mod 2016/03/29
# Latest version at <https://github.com/ryran/valine>
# Copyright 2014, 2016 Ryan Sawhill Aroha <rsaw@redhat.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#
#-------------------------------------------------------------------------------

# Program name
pzero=valine

# Get version from line #2
version=$(sed '2q;d' ${0})

# Colors
# FIXME: This is nonsense and simply due to poor planning (wasn't originally going to use colors so much)
BOLD='\033[1;1m'  ; B() { printf ${BOLD}; }
RESET='\033[0;0m' ; R() { printf ${RESET}; }
r='\033[0;31m'    ; r() { printf ${r}; }
g='\033[0;32m'    ; g() { printf ${g}; }
G='\033[1;32m'    ; G() { printf ${G}; }
b='\033[1;34m'
B='\033[1;34m'
y='\033[0;33m'    ; y() { printf ${y}; }
Y='\033[1;33m'    ; Y() { printf ${Y}; }
p='\033[0;35m'    ; p() { printf ${p}; }
P='\033[1;35m'    ; P() { printf ${P}; }
c='\033[0;36m'    ; c() { printf ${c}; }
C='\033[1;36m'    ; C() { printf ${C}; }
Z() { printf ${b}; }

# Some global variables
skipPrompts=false
allDomains=false
startDomains=true
nonthinSnapshotLvDefaultSize=2G
XML=
lvmCfgfileVersion='0Sifr'
lvmCfgfileColumnNames='ID❚LV❚VG❚Origin❚ThinPool❚Date❚Time'
numTimesTrapTriggered=0
# GNU getopt short and long options
sOpts='ahL:'
lOpts='all,off,help,size:'

Print() {
    if [[ -n ${2} ]]; then
        ${2}
        echo -e "${1}${RESET}"
    else
        echo -e "${BOLD}${1}${RESET}"
    fi
}

Prompt() {
    local REPLY
    if [[ ${skipPrompts} == true ]]; then
        echo "${@} [y/n] y"
    else
        read -p "${@} [y/n] "
        [[ ${REPLY} == y ]]
        return
    fi
}

Loop() {
    local interval lasttime
    if [[ ${#} -eq 0 || ${1} = --help || ${1} = -h || ${1} = -\? ]]; then
        echo "Usage: Loop [-N] COMMAND"
        echo "Runs COMMAND [waiting N sec between failed attempts] until it succeeds"
        echo "If wait interval N is not specified, it defaults to 2 sec"
    else
        [[ ${1#-} -gt 0 ]] && { interval=${1#-}; shift; } || interval=2
        lasttime=$(date +%s)
        until ${@}; do
            if [[ $(date +%s) -gt $((lasttime+interval+120)) ]]; then
                echo "${pzero}: ${1} command just exited with non-zero status; however, since it's been"
                echo "        more than 2 mins since initial success, we broke the loop"
                break
            else
                lasttime=$(date +%s)
            fi
            sleep ${interval}
        done
    fi
}

wait_for_domid_turn_to_dash() {
    local count=0
    [[ ${parallelize} == false ]] && local printProgress="printf ."
    until [[ $(virsh domid ${1}) == - ]]; do
        ((count++))
        sleep .5
        ${printProgress}
        case ${count} in
            8)   echo; echo -e "      ${Domain}: Waiting for domain to turn off" ;;
            30)  echo; echo -e "      ${Domain}: Domain has not yet turned off (still waiting)" ;;
            120) echo; echo -e "      ${Domain}: Domain has not yet turned off\n        Consider manual intervention on the domain's serial or physical console" ;;
            340) echo; echo -e "      ${Domain}: Domain still has not turned off\n        Manual intervention on the console is probably required\n        No more warnings will be printed" ;;
        esac
    done
}

wait_for_shutdown() {
    if [[ $(virsh domid ${1}) == - ]]; then
        echo "  Already off"
        return
    fi
    if [[ ${parallelize} == true ]]; then
        virsh shutdown ${1} &>/dev/null
        wait_for_domid_turn_to_dash ${1}
    else
        echo "  Shutting down domain"
        virsh shutdown ${1} &>/dev/null
        printf "    Waiting for domain to shut down gracefully ..."
        wait_for_domid_turn_to_dash ${1}
    fi
    echo
}

wait_for_destroy() {
    if [[ $(virsh domid ${1}) == - ]]; then
        echo "  Already off"
        return
    fi
    if [[ ${parallelize} == true ]]; then
        virsh destroy ${1} &>/dev/null
        wait_for_domid_turn_to_dash ${1}
    else
        echo "  Forcefully terminating domain"
        virsh destroy ${1} &>/dev/null
        printf "    Waiting for domain to terminate ..."
        wait_for_domid_turn_to_dash ${1}
    fi
    echo
}

show_usage() {
    echo -e "${BOLD}Usage: ${pzero}
       ${BOLD}${pzero} DOMAIN
       ${BOLD}${pzero} DOMAIN new-snap [SNAP] [--off] [--size LVSIZE]
       ${BOLD}${pzero} DOMAIN revert-snap [SNAP] [--off]
       ${BOLD}${pzero} DOMAIN Delete-snap SNAP
       ${BOLD}${pzero} DOMAIN {start|Shutdown|Hard-reboot|hibernate|destroy|NUKE}
       ${BOLD}${pzero} DOMAIN {console|loop-ssh}
       ${BOLD}${pzero} DOMAIN Change-media [/path/to/iso]
       ${BOLD}${pzero} DOMAIN {set-maxmem|set-mem} SIZE[k|M|G|T]
       ${BOLD}${pzero} --all {new-snap|revert-snap|start|Shutdown|Hard-reboot|
                     ${BOLD}hibernate|destroy}${RESET}"
    [[ ${1} == +note ]] && echo -e "\nRun ${BOLD}${pzero} --help${RESET} for full help page"
}

show_help() {
    show_usage
    echo -e "
Easy qcow & LVM snapshot mgmt of libvirt guests w/ intelligent tab-completion

${BOLD}With no subcommands:${RESET}
 ┐
 │${BOLD}${pzero}${RESET}
 │  • Display summary of all domains & their storage (including snapshots)
 │
 │${BOLD}${pzero} DOMAIN${RESET}
 │  • Show virsh dominfo & domblklist along with snapshot details
 └──────────────────────────────────────────────────────────────────────────────

${BOLD}Snapshotting with ${pzero}:${RESET}
 ┐
 │${BOLD}${pzero} DOMAIN {n|new-snap} [SNAP] [--off] [--size LVSIZE]${RESET}   (NO confirmation)
 │  • If provided, SNAP will be the name of the new snapshot
 │     • Otherwise, name will be auto-generated
 │  • Wait for DOMAIN to shut down
 │  • Determine storage type
 │  • If QCOW2 storage:
 │      • Create new embedded snapshot w/ virsh snapshot-create-as
 │        (Doing this more than once always leads to nested snapshots)
 │  • If LVM storage:
 │      • Check if current storage LV is thin-provisioned
 │          • If so, create a new thin LV snapshot from it (no size needed)
 │          • If not, size will be LVSIZE (default 2GiB) and
 │              • Check if current storage LV is a snapshot
 │                  • If so, create a new snapshot of its origin
 │                  • If not, create a new snapshot of it
 │      • Redfine DOMAIN xml to use the newly-created snapshot
 │      • Add new snapshot to /var/lib/${pzero}/DOMAIN
 │  • If not --off:
 │      • Starts DOMAIN with new snapshot
 │
 │${BOLD}${pzero} DOMAIN {r|revert-snap} [--off]${RESET}                       (NO confirmation)
 │  • Wait for DOMAIN to be destroyed
 │  • If QCOW2 storage:
 │      • Revert current snapshot to original pristine state using
 │          virsh snapshot-revert DOMAIN --current
 │  • If LVM storage:
 │      • Remove current snapshot LV (lvremove) & recreate it from its origin
 │      • Update creation date/time of snapshot in /var/lib/${pzero}/DOMAIN
 │  • If not --off:
 │      • Starts DOMAIN with new snapshot
 │
 │${BOLD}${pzero} DOMAIN {r|revert-snap} SNAP [--off]${RESET}                  (NO confirmation)
 │  • If QCOW2 storage, SNAP should be an embedded snapshot name:
 │      • Wait for DOMAIN to be destroyed
 │      • Revert SNAP to original pristine state and set it as current, using
 │          virsh snapshot-revert DOMAIN SNAP
 │  • If LVM storage, SNAP should be the LV name [only] of an LVM logvol:
 │      • Prompt for whether to shut down or destroy DOMAIN
 │      • Find SNAP in /var/lib/${pzero}/DOMAIN & confirm it's available with lvs
 │      • Edit 'source dev' definition in DOMAIN xml to point to SNAP, 
 │        whether it's a snapshot or a normal LVM logvol, using
 │            virsh dumpxml; sed; virsh undefine; virsh define
 │  • If not --off:
 │      • Starts DOMAIN with fresh snapshot or different LVM storage
 │
 │${BOLD}${pzero} DOMAIN {D|Delete-snap} SNAP${RESET}                         (YES confirmation)
 │  • If QCOW2 storage, SNAP should be an embedded snapshot name:
 │      • Check if SNAP is the current snapshot
 │          • If so, give warning deleting current SNAP is not recommended
 │      • Delete SNAP using: virsh snapshot-delete DOMAIN SNAP
 │  • If LVM storage, SNAP should be the LV name [only] of an LVM logvol:
 │      • Abort with warning if SNAP is the current storage
 │      • Remove current snapshot LV (lvremove) & /var/lib/${pzero}/DOMAIN
 │
 │For more on managing snapshots with virsh:
 │    Virtualization Deployment & Administration Guide @ http://red.ht/1kwfbJs 
 └──────────────────────────────────────────────────────────────────────────────

${BOLD}Starting/stopping/saving/deleting domains with ${pzero}:${RESET}
 ┐
 │${BOLD}${pzero} DOMAIN {s|start}${RESET}
 │
 │${BOLD}${pzero} DOMAIN {S|Shutdown}${RESET}
 │  • Attempt a graceful shutdown via acpi signaling
 │
 │${BOLD}${pzero} DOMAIN {H|Hard-reboot}${RESET}
 │  • Perform hard power reset (immediate reboot)
 │
 │${BOLD}${pzero} DOMAIN {d|destroy}${RESET}
 │  • Cut the power (immediate shutdown)
 │
 │${BOLD}${pzero} DOMAIN {h|hibernate}${RESET}
 │  • Save RAM to statefile via virsh managedsave DOMAIN
 │
 │${BOLD}${pzero} DOMAIN {N|NUKE}${RESET}
 │  • Completely removes a VM by executing:
 │      • virsh destroy DOMAIN
 │      • virsh undefine DOMAIN --snapshots-metadata --remove-all-storage \\
 │                              --nvram --managed-save
 └──────────────────────────────────────────────────────────────────────────────

${BOLD}Accessing domains with ${pzero}:${RESET}
 ┐
 │${BOLD}${pzero} DOMAIN {c|console}${RESET}
 │  • Open serial console
 │
 │${BOLD}${pzero} DOMAIN {l|loop-ssh}${RESET}
 │  • Keep trying to ssh to DOMAIN until success
 │    (Uses 'until ssh DOMAIN; do sleep 2; done' loop)
 │    This assumes DOMAIN is reachable via DNS or ssh-config
 └──────────────────────────────────────────────────────────────────────────────

${BOLD}Making changes to domains with ${pzero}:${RESET}
 ┐
 │${BOLD}${pzero} DOMAIN {C|Change-media} [/path/to/iso]${RESET}
 │  • Insert new iso file (requires existing cdrom)
 │  • If no iso specified, eject existing
 │
 │${BOLD}${pzero} DOMAIN set-maxmem SIZE[k|M|G|T]${RESET}
 │  • Change the maximum memory allocation limit for DOMAIN
 │  • Changes to this setting only take effect after DOMAIN is powered off
 │  • SIZE suffix defaults to 'k' (i.e., kibibytes)
 │
 │${BOLD}${pzero} DOMAIN set-mem SIZE[k|M|G|T]${RESET}
 │  • Change the current memory allocation limit for DOMAIN
 │  • Changes to this setting take effect immediately
 │  • SIZE suffix defaults to 'k' (i.e., kibibytes)
 └──────────────────────────────────────────────────────────────────────────────

${BOLD}Managing ALL domains at once with ${pzero}:${RESET}
 ┐
 │${BOLD}${pzero} --all {n|new-snap} | {r|revert-snap} | {s|start} | {S|Shutdown} |${RESET}
 │             ${BOLD}{H|Hard-reboot} | {h|hibernate} | {d|destroy}${RESET}
 │Replace DOMAIN with '--all' (or '-a') to operate on all detected domains in
 │parallel (jobs are backgrounded, verbose output is lessened, and cancelling
 │requires double Ctrl-c)
 │Note: Does not work with cmds: console, Delete-snap, NUKE, set-maxmem, set-mem
 │As above, the --off switch is optional with new-snap and revert-snap
 └──────────────────────────────────────────────────────────────────────────────

${BOLD}Version info: ${version:2}${RESET}
  See <http://github.com/ryran/valine> to report bugs or suggestions"
}

get_primary_storage_source() {
    primaryStorageSourceXmlLine=$(virsh dumpxml --inactive "${Domain}" | egrep "<source (file|dev)=" | head -1)
    primaryStorage=$(cut -d\' -f2 2>/dev/null <<<"${primaryStorageSourceXmlLine}")
}

sanitize_lvm_path_primaryStorage() {
    if [[ ${primaryStorage} =~ ^/dev/mapper/ ]]; then
        # Turn /dev/mapper/vg-lv into /dev/vg/lv
        # Sed nonsense is to deal with valid double-dashes in vg or lv names
        primaryStorage="/dev/$(sed -r -e 's,([^-])-([^-]),\1/\2,' -e 's,--,-,g' <<<"${primaryStorage#/dev/mapper/}")"
    fi
}

test_primaryStorage_is_lvm() {
    if [[ $(stat -c %t $(readlink -f "${primaryStorage}")) == fd ]]; then
        sanitize_lvm_path_primaryStorage
        return 0
    else
        return 1
    fi
}

domain_cfgfile_create() {
    if [[ ! -d ${cfgFile##*/} ]] && ! mkdir -p ${cfgFile##*/}; then
        Print "Error: Missing [and unable to create] needed directory '${cfgFile##*/}'" r
        Print "As root, execute:"
        Print "  mkdir -m 2775 ${cfgFile##*/}; chgrp libvirt ${cfgFile##*/}"
        exit 64
    fi >&2
    cat >${cfgFile} <<EOF
# Domain:     ${Domain}
# CfgVersion: ${lvmCfgfileVersion}
# Columns:    ${lvmCfgfileColumnNames}

EOF
}

domain_cfgfile_eval() {
    if [[ $(awk '/^# CfgVersion:/ {print $3}' ${cfgFile} 2>/dev/null) != ${lvmCfgfileVersion} ]]; then
        Print "Warning: ${Domain} config file has improper CfgVersion ('${lvmCfgfileVersion}' expected)" r
        Print "Storage displayed for this domain might not be accurate" r
        Print "If this causes problems, delete ${cfgFile}" r
        return 64
    fi >&2
    # Set global variable containing current storage's LVM VG name
    lvmVolgroup=$(get_lv_attribute VG of LV=${primaryStorage##*/})
}

domain_cfgfile_add_lvm_snap() {
    echo "${ID}❚${LV}❚${VG}❚${Origin}❚${ThinPool}❚${Date}❚${Time}" >>${cfgFile}
}

chase_add_preexisting_logvols() {
    local id=0 logvol=${1} LVM2_VG_NAME LVM2_LV_NAME LVM2_LV_PATH LVM2_ORIGIN=0 LVM2_POOL_LV 
    while [[ -n ${LVM2_ORIGIN} ]]; do
        eval $(sudo -n lvm lvs --nameprefixes --noheadings -o vg_name,lv_name,lv_path,origin,pool_lv ${logvol})
        ID=${id} LV=${LVM2_LV_NAME} VG=${LVM2_VG_NAME} Origin=${LVM2_ORIGIN} \
            ThinPool=${LVM2_POOL_LV} Date=unknown Time=unknown \
            domain_cfgfile_add_lvm_snap
        ((id++))
        siblings=$(sudo -n lvm lvs --noheadings -o vg_name,origin,lv_name ${LVM2_VG_NAME} 2>/dev/null | 
                       awk -v vg="${LVM2_VG_NAME}" -v origin="${LVM2_ORIGIN}" -v lv=${LVM2_LV_NAME} '
                           $1 == vg && $2 == origin && $3 != lv {print $3}'
                 )
        for logvol in ${siblings}; do
            eval $(sudo -n lvm lvs --nameprefixes --noheadings -o vg_name,lv_name,lv_path,origin,pool_lv ${LVM2_VG_NAME}/${logvol})
            ID=${id} LV=${LVM2_LV_NAME} VG=${LVM2_VG_NAME} Origin=${LVM2_ORIGIN} \
                ThinPool=${LVM2_POOL_LV} Date=unknown Time=unknown \
                domain_cfgfile_add_lvm_snap
            ((id++))
        done
        logvol=${LVM2_VG_NAME}/${LVM2_ORIGIN}
    done
}

test_have_sudo_lvm() {
    if sudo -nl lvm &>/dev/null; then
        return
    else
        case ${1} in
            inspect) Print "Error: Unable to fully-inspect storage '${primaryStorage}' for domain '${Domain}'" y ;;
            create)  Print "Error: Unable to create new LVM snapshot for domain '${Domain}'" y ;;
            revert)  Print "Error: Unable to revert LVM snapshot storage for domain '${Domain}'" y ;;
            delete)  Print "Error: Unable to delete LVM snapshot storage for domain '${Domain}'" y ;;
        esac
        Print "To fix this, run as root:" y
        Print "  echo '${USER} ALL=(ALL) NOPASSWD: /usr/sbin/lvm' >>/etc/sudoers.d/${pzero}-lvm" y
        return 1
    fi >&2
}

read_lvm_config() {
    cfgFile=/var/lib/${pzero}/${Domain}
    if [[ -r ${cfgFile} ]]; then
        domain_cfgfile_eval
    elif test_have_sudo_lvm inspect; then
        domain_cfgfile_create
        chase_add_preexisting_logvols ${primaryStorage}
        domain_cfgfile_eval
    fi
}

test_primaryStorage_is_qcow2() {
    local imageType=$(qemu-img info "${primaryStorage}" | awk '/file format:/ {print $3}')
    [[ ${imageType} == qcow2 ]]
}

set_type_primary_storage_source() {
    get_primary_storage_source
    if [[ -z ${primaryStorage} || ${primaryStorage} =~ \.iso ]]; then 
        storageType=unknown
    else
        if [[ ${primaryStorageSourceXmlLine} =~ source.dev= ]]; then
            if test_primaryStorage_is_lvm; then
                storageType=lvm
                read_lvm_config
            else
                storageType="raw block"
            fi
        else
            test_primaryStorage_is_qcow2 && storageType=qcow2 || storageType="raw image"
        fi
    fi
}

get_lv_attribute() {
    # $1 = desired.column.name
    # $2 = "of"
    # $3 = lv.column.name=VALUE
    local c= i=0 j=0
    for c in ${lvmCfgfileColumnNames//❚/ }; do ((i++)); [[ ${c} == ${1} ]] && break; done
    c=
    for c in ${lvmCfgfileColumnNames//❚/ }; do ((j++)); [[ ${c} == ${3%%=*} ]] && break; done
    awk -F❚ -v desiredColumn="${i}" -v lvColumn="${j}" -v lvColValue="${3#*=}" '
        BEGIN{ E = 1 }
        {
            if (NF == 0 || $1 ~ /^\s*($|#)/)
                next
            else {
                if ($lvColumn == lvColValue) {
                    if ($desiredColumn != "") {
                        print $desiredColumn
                        E = 0
                    }
                }
            }
        }
        END{ exit E }
    ' ${cfgFile}
}

update_lv_attrs_datetime() {
    # $1 = lv.id
    local id=${1}
    sed -i -r \
        -e "/^${id}❚/s,(.*❚.*❚.*❚.*❚.*)❚.*❚,\1❚$(date +%F)❚," \
        -e "/^${id}❚/s,(.*❚.*❚.*❚.*❚.*❚.*)❚.*,\1❚$(date "+%T %z")," ${cfgFile}
}

lvm_print_children_of_parent() {
    local parent=${1} indent=${2} count=0 child pre printchild
    for child in $(get_lv_attribute LV of Origin=${parent}); do
        ((count++))
    done
    for child in $(get_lv_attribute LV of Origin=${parent}); do
        ((count--))
        pre= printchild=
        
        # FOR DISPLAY ON THIS CHILD'S LINE:
        if [[ ${count} -eq 0 ]]; then
            [[ ${indent} =~ │$ ]] && indent=${indent%│}
            pre="${indent}└"  # No other children
        else
            [[ ${indent} =~ │$ ]] && indent=${indent%│}
            pre="${indent}├"  # At least 1 more child
        fi
        
        # Print child
        if [[ ${child} == ${primaryStorage##*/} ]]; then
            printchild="${C}${child}${RESET} $(__arrow)"
        else
            printchild="${c}${child}${RESET}"
        fi
        printf "${pre}─${printchild}\n"
        
        # If child is also a parent:
        if get_lv_attribute LV of Origin=${parent} >/dev/null; then
            # What to do with indent for next loop:
            if [[ ${count} -eq 0 ]]; then
                # If our parent doesn't have another child:                
                indent="${indent} "  # FOR NEXT CHILD
            elif [[ ${count} -ge 1 ]]; then
                # If our parent has at least 1 more child: 
                indent="${indent}│"
            fi
            # Execute loop with current child as the parent
            lvm_print_children_of_parent ${child} "${indent}   "
        fi
    done
}

print_domains_lvm_storage() {
    if [[ ! -r ${cfgFile} ]]; then
        printf "${primaryStorage} $(__arrow)\n"
        return
    fi
    local topLevelLogvol= vg=
    for topLevelLogvol in $(get_lv_attribute LV of Origin=""); do
        vg=$(get_lv_attribute VG of LV=${topLevelLogvol})
        if [[ ${primaryStorage} == /dev/${vg}/${topLevelLogvol} ]]; then
            printf "/dev/${vg}/${C}${topLevelLogvol}${RESET} $(__arrow)\n"
        else
            printf "/dev/${vg}/${c}${topLevelLogvol}${RESET}\n"
        fi
        lvm_print_children_of_parent ${topLevelLogvol} "  " 
    done
}

print_domains_qcow_snapshots() {
    printf "\n❚❚❚  └─$(c)"
    virsh snapshot-list ${Domain} --tree |
        sed -n -e "/| *$/ d;1h;1!H
            $ {x
            :a
                s/\(\n[ |]*\)+\([^[:cntrl:]]*\1[|+]\)/\1├\2/;t a
            :b
                s/\(\n[ |]*\)+/\1└/;t b
                s/|/│/g;s/- /─$(c)/g;p
            }" | 
                sed \
                    -e '/^ *$/d'            \
                    -e '1!s,^,❚❚❚    ,'    \
                    -e "s,$(virsh snapshot-current ${Domain} --name),$(C)&$(R) $(__arrow),"  \
                    -e "s,$,$(R),"
                    #~ -e 's,|,│,g'           \
                    #~ -e "s,+- ,└─$(c),"     \
                    #~ -e '/^[ │]*$/d'        
}

__arrow() { printf "${G}←${RESET}" ; }

_list_dom_state_and_snaps() {
    # Fun symbols to maybe use
    # ✔ ← ☀ ☚ ⚑ ◄ ◀ ◉
    set_type_primary_storage_source
    case ${storageType} in
        unknown|raw*)
            line=" ${Domain} ❚${1}❚${storageType} ❚${primaryStorage} $(__arrow)"
            ;;
        lvm)
            line=" ${Domain} ❚${1}❚lvm ❚"
            line+=$(print_domains_lvm_storage | sed '1!s/^/❚❚❚/')
            ;;
        qcow2)
            line=" ${Domain} ❚${1}❚qcow2 ❚"
            line+="${primaryStorage}"
            if [[ -z $(virsh snapshot-list ${Domain} --name) ]]; then
                line+=" $(__arrow)"
            else
                line+=$(print_domains_qcow_snapshots)
            fi
            ;;
    esac
    # Got rid of blank lines in valine v0.7.1:
    #line+="\n❚❚❚\n"
    line+="\n"
    printf "${line}"
}

list_virts_and_snapshots() {
    {
        echo -e "❚❚❚\n DOMAIN❚⚡❚STORAGE❚SNAPSHOTS\n❚❚❚"
        for Domain in $(virsh list --name); do
            _list_dom_state_and_snaps "◉"
        done
        for Domain in $(virsh list --inactive --name); do
            _list_dom_state_and_snaps "◌"        
        done
        echo "❚❚❚"
    } |
        column -t -s "❚" -o " │ " |
            sed  \
                -e '1 s/│/┬/g' -e '1 s/ /─/g' -e "1 s/^/$(Z)/" -e "1 s/$/──────────────────────────────────────────$(R)/" \
                -e '3 s/│/┼/g' -e '3 s/ /─/g' -e "3 s/^/$(Z)/" -e "3 s/$/──────────────────────────────────────────$(R)/" \
                -e '$ s/│/┴/g' -e '$ s/ /─/g' -e "$ s/^/$(Z)/" -e "$ s/$/──────────────────────────────────────────$(R)/" \
                -e "s/│/$(Z)│$(R)/1" -e "s/│/$(Z)│$(R)/2" -e "s/│/$(Z)│$(R)/3" \
                -e "s/◉/$(g)&$(R)/" -e "s/◌/$(r)&$(R)/" \
                -r -e "2 s/ [⚡[:upper:]]*/$(Y)&$(R)/g" \
                   -e "s/^ [[:graph:]]+/$(B)&$(R)/"
    echo -e "\nKey:"
    echo -e "  • Each domain's current storage is marked with a green arrow: $(__arrow)"
    echo -e "  • Storage which is revertable & Deletable is displayed in ${c}cyan${RESET}\n"
}

list_domain_qcow_embedded_snaps() {
    [[ -n ${1} ]] && local Domain=${1}
    {
        echo -e "❚❚❚\n Name❚Parent❚Date❚Time\n❚❚❚"
        virsh snapshot-list ${Domain} --parent | 
            tail -n+3 |
                awk 'NF!=0 { printf " %s❚%s❚%s❚%s %s\n", $1, $6, $2, $3, $4 }'
        echo "❚❚❚"
    } | column -ts❚  -o " │ " |
        sed  \
            -e 's/(null)/      /' \
            -e '1 s/│/┬/g' -e '1 s/ /─/g' -e "1 s/$/──────────────────/" \
            -e '3 s/│/┼/g' -e '3 s/ /─/g' -e "3 s/$/──────────────────/" \
            -e '$ s/│/┴/g' -e '$ s/ /─/g' -e "$ s/$/──────────────────/"
}

list_domain_lvm_storage() {
    [[ -n ${1} ]] && local Domain=${1}
    cfgFile=/var/lib/${pzero}/${Domain}
    awk -F❚ -v columns="${lvmCfgfileColumnNames}" '
        BEGIN {
            OFS="❚"
            printf "❚❚❚❚❚❚\n %s\n❚❚❚❚❚❚\n", columns
        }
        {
            if (NF == 0 || $1 ~ /^\s*($|#)/)
                next
            else {
                printf " "
                print
            }
        }
        END {
            printf "❚❚❚❚❚❚\n"
        }
    ' ${cfgFile} | column -ts❚  -o " │ " |
            sed  \
                -e '1 s/│/┬/g' -e '1 s/ /─/g' -e "1 s/$/──────────────────/" \
                -e '3 s/│/┼/g' -e '3 s/ /─/g' -e "3 s/$/──────────────────/" \
                -e '$ s/│/┴/g' -e '$ s/ /─/g' -e "$ s/$/──────────────────/"
}

list_snaps() {
    case ${storageType} in
        lvm)
            list_domain_lvm_storage
            ;;
        qcow2)
            list_domain_qcow_embedded_snaps
            ;;
        *)
            Print "Error: ${pzero} does not yet manage ${Domain}'s storage type (${storageType})"
            exit 64
    esac
}

get_next_available_lvm_snapshot_name() {
    local n=0 origin=${1}
    while [[ -e ${origin}-snap${n} ]]; do
        ((n++))
    done
    echo ${origin##*/}-snap${n}
}

get_next_available_lvm_snapshot_id() {
    local id=0 n
    for n in $(egrep ^[0-9]+❚ ${cfgFile} | cut -d❚ -f1 | sort -n); do
        [[ ${n} != ${id} ]] && break || ((id++))
    done
    echo ${id}
}

get_domain_xml() {
    # Create a temp-file for the guest definition
    XML=$(mktemp -p /tmp ${pzero}.${Domain}.XXXX)
    trap "rm ${XML}" EXIT
    chcon -t virt_etc_rw_t ${XML}
    # Save guest definition to temp-file
    virsh dumpxml --inactive ${Domain} >${XML}
}

switch_domain_storage_to() {
    if [[ ${storageType} != lvm ]]; then
        Print "Error: Switching domain storage is currently only supported with LVM"
        exit 64
    fi
    local currentStorage=${primaryStorage} newStorage=${1}
    [[ -z ${XML} ]] && get_domain_xml
    if ! egrep -q "source (dev|file)='${currentStorage}'" ${XML}; then
        currentStorage=${currentStorage##*/} currentStorage=/dev/mapper/${currentStorage//-/--}
        if ! egrep -q "source (dev|file)='${currentStorage}'" ${XML}; then
            Print "Error: Domain ${Domain} does not appear to have primary storage ('${primaryStorage}')"
            exit 64
        fi
    fi
    sed -i -r "/source (dev|file)='${currentStorage//\//\\/}'/s,${currentStorage},${newStorage}," ${XML}
    [[ ${parallelize} == false ]] && printf "  "
    virsh undefine ${Domain} | sed '/^$/d'
    [[ ${parallelize} == false ]] && printf "  "
    virsh define ${XML} | sed '/^$/d'
    primaryStorage=${newStorage}
}

exec_must_succeed() {
    local msg=${1}
    shift
    if ! ${@}; then
        Print "${msg}"
        echo "Aborting"
        exit 64
    fi
}

create_new_lvm_snapshot() {
    local origin=${1} snapshotName=${2} snapshotSize
    if get_lv_attribute ThinPool of LV=${origin##*/} >/dev/null; then
        Print "${Domain}: Creating new thin LVM snapshot from thin origin ${origin#/dev/}"
        exec_must_succeed "Error: Problem creating snapshot ${lvmVolgroup}/${snapshotName}" \
                          sudo -n lvm lvcreate --setactivationskip n --snapshot --name ${snapshotName} ${origin}
    else
        if [[ -n ${snapshotDesiredSize} ]]; then
            snapshotSize=${snapshotDesiredSize}
        else
            snapshotSize=${nonthinSnapshotLvDefaultSize}
        fi
        Print "${Domain}: Creating new ${snapshotSize} lvm snapshot from origin ${origin#/dev/}"
        exec_must_succeed "Error: Problem creating snapshot ${lvmVolgroup}/${snapshotName}" \
                          sudo -n lvm lvcreate --snapshot --name ${snapshotName} --size ${snapshotSize} ${origin}
    fi
}

new_snap() {
    local snapshotDesiredName=${1} snapshotName origin=
    if [[ ${storageType} =~ raw|unknown ]]; then
        Print "Error: ${pzero} does not yet manage ${Domain}'s storage type (${storageType})"
        exit 64
    elif [[ ${storageType} == lvm ]]; then
        test_have_sudo_lvm create || exit 64
    fi
    Print "${Domain}: Must be shut down in order to create new snapshot"
    wait_for_shutdown ${Domain}
    case ${storageType} in
        lvm)
            if ! get_lv_attribute ThinPool of LV=${primaryStorage##*/} >/dev/null && origin=$(get_lv_attribute Origin of LV=${primaryStorage##*/}); then
                origin=/dev/${lvmVolgroup}/${origin}
            else
                origin=${primaryStorage}
            fi
            if [[ -n ${snapshotDesiredName} ]]; then
                snapshotName=${snapshotDesiredName}
            else
                snapshotName=$(get_next_available_lvm_snapshot_name ${origin})
            fi
            create_new_lvm_snapshot ${origin} ${snapshotName}
            ID=$(get_next_available_lvm_snapshot_id) LV=${snapshotName} VG=${lvmVolgroup} \
                Origin=${origin##*/} ThinPool=$(get_lv_attribute ThinPool of LV=${origin##*/}) \
                Date=$(date +%F) Time=$(date "+%T %z") \
                domain_cfgfile_add_lvm_snap
            Print "${Domain}: Configuring domain to use new snapshot ${lvmVolgroup}/${snapshotName} as primary storage"
            switch_domain_storage_to /dev/${lvmVolgroup}/${snapshotName}
            ;;
        qcow2)
            Print "${Domain}: Creating new qcow2-based snapshot, tagging it as current"
            [[ ${parallelize} == false ]] && printf "  "
            virsh snapshot-create-as ${Domain} ${snapshotDesiredName}
            ;;
    esac
    if [[ ${startDomains} == true ]]; then
        Print "${Domain}: Starting with pristine snapshot"
        [[ ${parallelize} == false ]] && printf "  "
        virsh start ${Domain}
    fi
}

revert_snap() {
    local snapshotName=${1}
    if [[ ${storageType} == lvm ]]; then
        test_have_sudo_lvm revert || exit 64
        if [[ -z ${snapshotName} ]]; then
            Print "${Domain}: Must be off to recreate current snapshot logvol"
            wait_for_destroy ${Domain}
            if origin=$(get_lv_attribute Origin of LV=${primaryStorage##*/}); then
                origin=/dev/${lvmVolgroup}/${origin}
            else
                Print "Error: Domain's primary storage (${primaryStorage#/dev/}) is not a snapshot"
                exit
            fi
            sudo -n lvm lvremove -f ${primaryStorage}
            create_new_lvm_snapshot ${origin} ${primaryStorage##*/}
            update_lv_attrs_datetime $(get_lv_attribute ID of LV=${primaryStorage##*/})
        else
            if [[ $(virsh domid ${Domain}) != - ]]; then
                Print "${Domain}: Must be off to change which logvol is in use"
                echo "  Do you want to shutdown gracefully or force destroy?" 
                echo "  (Choose shutdown if you plan to use the current storage again)"
                read -ep "  [S]hutdown or [d]estroy? > "
                case "${REPLY}" in
                    s|S|shutdown)
                        wait_for_shutdown ${Domain}
                        ;;
                    d|D|destroy)
                        wait_for_destroy ${Domain}
                        ;;
                    *)
                        Print "Error: Improper choice"
                        exit
                esac
            fi
            Print "${Domain}: Configuring domain to use logvol ${lvmVolgroup}/${snapshotName} as primary storage"
            switch_domain_storage_to /dev/${lvmVolgroup}/${snapshotName}
            if [[ ${startDomains} == true ]]; then
                Print "${Domain}: Starting ..."
                [[ ${parallelize} == false ]] && printf "  "
                virsh start ${Domain}
            fi
            return
        fi
    elif [[ ${storageType} == qcow2 ]]; then
        if [[ -n ${snapshotName} ]]; then
            Print "${Domain}: Must be off to switch to another snapshot"
            wait_for_destroy ${Domain}
            Print "${Domain}: Switching to newly-reverted snapshot ${snapshotName}"
            virsh snapshot-revert ${Domain} "${snapshotName}"
        else
            Print "${Domain}: Must be off to revert changes to snapshot"
            wait_for_destroy ${Domain}
            Print "${Domain}: Reverting changes to current snapshot"
            virsh snapshot-revert ${Domain} --current
        fi
    else
        Print "${Domain}: Error: 'revert-snap' command does not yet support storage type '${storageType}'"
        exit 64
    fi
    if [[ ${startDomains} == true ]]; then
        Print "${Domain}: Starting with pristine snapshot"
        [[ ${parallelize} == false ]] && printf "  "
        virsh start ${Domain}
    fi
}

delete_snap() {
    case ${storageType} in
        lvm)
            test_have_sudo_lvm delete || exit 64
            if [[ ${primaryStorage} == /dev/${lvmVolgroup}/${1} ]]; then
                Print "Error: Cannot delete current storage for domain ${Domain}"
                echo "You must switch to alternate storage first"
                exit
            fi
            Print "About to remove storage /dev/${lvmVolgroup}/${1} from domain ${Domain}"
            Prompt "  Continue?" || return
            sudo -n lvm lvremove -f /dev/${lvmVolgroup}/${1}
            storageName=${1} remove_stale_lvm_storage_from_config
            ;;
        qcow2)
            if [[ $(virsh snapshot-current ${Domain} --name) == ${1} ]]; then
                Print "Warning: It's usually not a good idea to delete an active snapshot" r
                Print "Recommendation: If possible, revert to another snapshot first" r
            fi
            Print "About to remove snapshot ${1} from domain ${Domain}"
            Prompt "  Continue?" || return
            virsh snapshot-delete ${Domain} "${1}"
            ;;
        *)
            Print "Error: ${pzero} does not yet manage ${Domain}'s storage type (${storageType})"
            exit 64
    esac
}

domblklist_cdrom() {
    virsh domblklist "${1}" --details | awk '$2=="cdrom" {printf "%s=%s\n", $3, $NF; exit}' 2>/dev/null
}

nuke_domain() {
    Print "About to UNDEFINE domain ${Domain} and DELETE all of its attached storage"
    Print "THIS OPERATION CANNOT BE UNDONE!"
    Prompt "  Continue?" || return
    wait_for_destroy "${Domain}"
    cdrom=$(domblklist_cdrom "${Domain}")
    if [[ -n ${cdrom} ]]; then
        cdromDevice=${cdrom%%=*}
        cdromSource=${cdrom#*=}
        change_media 2>/dev/null
    fi
    virsh undefine "${Domain}" --snapshots-metadata --remove-all-storage --nvram --managed-save
    rm "${cfgFile}" 2>/dev/null
}

change_media() {
    local live=--live
    [[ $(virsh domid ${Domain}) == - ]] && live=
    if [[ -n ${1} ]]; then
        virsh change-media "${Domain}" ${cdromDevice} "$(readlink -m "${1}")" --insert --config ${live}
    else
        virsh change-media "${Domain}" ${cdromDevice} --eject --config ${live}
    fi
}

## Coming soon: subcommands to add nics, disks, tweak ram/cpu
# add_disk() {
#     qemu-img create -f qcow2 -o preallocation=metadata /var/lib/mkvm/images/four 1G
#     
# }

# add_nic() {
#     desiredTypeSource=${1}
#     if [[ -z ${desiredTypeSource} ]]; then
#         netType=network
#         netSource=default
#     else
#         netType=${desiredTypeSource%%=*}
#         netSource=${desiredTypeSource#*=}
#     fi
#     if ! virsh attach-interface "${Domain}" --type ${netType} --source ${netSource} --model virtio --persistent 2>/dev/null; then
#         virsh attach-interface "${Domain}" --type ${netType} --source ${netSource} --persistent 2>/dev/null
#     fi
# }

case_thru_args() {
    case ${1} in
        -bg)  parallelize=true ;;
          *)  parallelize=false ;;
    esac
    shift
    [[ ${allDomains} == true ]] && case "${1}" in
        # This hasn't been done yet if -a/--all was used
        new-snap|n|revert-snap|r|Delete-snap|D) set_type_primary_storage_source
    esac
    case "${1}" in
        new-snap|n)
            new_snap "${2}"
            ;;
        revert-snap|r)
            revert_snap "${2}"
            ;;
        Delete-snap|D)
            delete_snap "${2}"
            ;;
        start|s)
            [[ $(virsh domid ${Domain}) == - ]] && virsh start "${Domain}"
            ;;
        Shutdown|S)
            [[ $(virsh domid ${Domain}) != - ]] && virsh shutdown "${Domain}"
            ;;
        Hard-reboot|H)
            [[ $(virsh domid ${Domain}) != - ]] && virsh reset "${Domain}"
            ;;
        hibernate|h)
            [[ $(virsh domid ${Domain}) != - ]] && virsh managedsave "${Domain}" ${verbose}
            ;;
        destroy|d)
            [[ $(virsh domid ${Domain}) != - ]] && virsh destroy "${Domain}"
            ;;
        console|c)
            exec virsh console "${Domain}"
            ;;
        loop-ssh|l)
            Loop ssh "${Domain}"
            ;;
        NUKE|N)
            nuke_domain "${Domain}"
            ;;
        Change-media|C)
            change_media "${2}"
            ;;
        set-maxmem)
            [[ $(virsh domid ${Domain}) != - ]] && Print "${Domain}: Must be powered off completely to see maxmem change"
            virsh setmaxmem "${Domain}" "${2}" --config
            virsh dominfo "${Domain}" | grep memory:
            ;;
        set-mem)
            if [[ $(virsh domid ${Domain}) == - ]]; then
                virsh setmem "${Domain}" "${2}" --config
            else
                virsh setmem "${Domain}" "${2}" --config --live
            fi
            virsh dominfo "${Domain}" | grep memory:
            ;;
        # add-nic)
        #     add_nic "${2}"
        #     ;;
        *)
            Print "Error: improper argument '${1}'"
            echo
            show_usage +note
            exit 64
    esac
}

cleanup_bg_jobs() {
    ((numTimesTrapTriggered++))
    if [[ ${numTimesTrapTriggered} -eq 1 ]]; then
        echo
        Print "${pzero}: Background jobs still running"
        echo "  Hit Ctrl-c again to cancel all bg jobs & quit"
        sleep 1d
    else
        echo
        Print "${pzero}: Aborting background jobs"
        pkill --pgroup 0
    fi
}

test_domain_storage_exists() {
    case ${storageType} in
        lvm)
            [[ -e /dev/${lvmVolgroup}/${storageName} ]] && return
            ;;
        qcow2)
            virsh snapshot-list "${Domain}" --name | grep -q "^${storageName}$" && return
    esac
    return 1
}

remove_stale_lvm_storage_from_config() {
    [[ ${storageType} == lvm ]] || return
    local id=
    if id=$(get_lv_attribute ID of LV=${storageName}); then
        sed -i "/^${id}❚/d" ${cfgFile}
        echo "Notice: Removed non-existent '/dev/${lvmVolgroup}/${storageName}' from domain config" >&2
    fi
}

sanity_check_args() {
    if [[ $(id -u) == 0 ]]; then
        :
    elif groups | grep -q '\<libvirt\>'; then
        [[ -z $LIBVIRT_DEFAULT_URI ]] && export LIBVIRT_DEFAULT_URI=qemu:///system
    else
        Print "Error: Not root; need to be a member of 'libvirt' group"
        Print "Consider running as root:"
        Print "  usermod -aG libvirt $USER"
        exit 77
    fi
    if [[ -n ${snapshotDesiredSize} ]] && [[ ${2} != new && ${2} != n ]]; then
        Print "Error: --size can only be used with 'new' command"
        exit 64
    elif [[ -z ${1} ]]; then
        list_virts_and_snapshots
        exit
    elif [[ ${allDomains} == true ]]; then
        case "${1}" in
            NUKE|N)
                Print "Error: 'NUKE' command not allowed with --all"
                exit 64
                ;;
            loop-ssh|l)
                Print "Error: 'loop-ssh' command not compatible with --all"
                exit 64
                ;;
            console|c)
                Print "Error: 'console' command not compatible with --all"
                exit 64
                ;;
            Change-media|C)
                Print "Error: 'Change-media' command not compatible with --all"
                exit 64
                ;;
            Delete-snap|D)
                Print "Error: 'Delete-snap' command not compatible with --all"
                exit 64
                ;;
            revert-snap|r)
                if [[ -n ${2} ]]; then
                    Print "Error: Specifying snapshot name with 'revert-snap' command not allowed with --all"
                    exit 64
                fi
                ;;
            new-snap|n)
                if [[ -n ${2} ]]; then
                    Print "Error: Specifying snapshot name with 'new-snap' command not allowed with --all"
                    exit 64
                fi
                ;;
            set-maxmem|set-mem)
                Print "Error: '${1}' command not allowed with --all"
                exit 64
                ;;
            start|s|Shutdown|S|Hard-reboot|H|hibernate|h|destroy|d)
                :
                ;;
            *)
                if [[ -n ${1} ]]; then
                    Print "Error: Improper argument '${1}'"
                    echo
                    show_usage +note
                    exit 64
                fi
        esac
        return
    elif ! virsh list --all --name | grep -q "^${1}$"; then
        Print "Error: DOMAIN '${1}' not recognized"
        echo "Available domains:"
        virsh list --all --name | sed -e /^$/d -e 's/^/  • /'
        exit 64
    elif [[ -z ${2} ]]; then
        Domain=${1}
        virsh dominfo "${Domain}"
        virsh domblklist "${Domain}" --details
        set_type_primary_storage_source
        list_snaps
        exit
    elif [[ $2 =~ ^(Delete|D|set-maxmem|set-mem)$ && -z ${3} ]]; then
        case ${2} in
            Delete|D)
                Print "Error: Must specify snapshot name to delete" ;;
            set-maxmem|set-mem)
                Print "Error: Must specify memory size as a number with optional size suffix" ;;
        esac
        exit 64
    fi
    
    case "${2}" in
        new-snap|n|revert-snap|r|Delete-snap|D|start|s|Shutdown|S|Hard-reboot|H|hibernate|h|destroy|d|console|c|loop-ssh|l|NUKE|N|Change-media|C|set-maxmem|set-mem)
            : ;;
        *)
            Print "Error: Improper command '${2}'"
            echo
            show_usage +note
            exit 64
    esac
    
    [[ -n ${3} ]] && case "${2}" in
        new-snap|n|revert-snap|r|Delete-snap|D|Change-media|C|set-maxmem|set-mem)
            : ;;
        *)
            Print "Error: Improper argument '${3}'"
            echo
            show_usage +note
            exit 64
    esac
    
    case "${2}" in
        Change-media|C)
            local cdrom=$(domblklist_cdrom "${1}")
            if [[ -z ${cdrom} ]]; then
                Print "Error: Domain does not have a cdrom device"
                exit 64
            fi
            cdromDevice=${cdrom%%=*}
            cdromSource=${cdrom#*=}
    esac
    
    # Don't need to do unnecessary introspection if a simple start/Shutdown/hibernate/destroy/console was specified
    case "${2}" in
        new-snap|n|revert-snap|r|Delete-snap|D)
            : ;;
        *)  return
    esac
    
    Domain=${1}
    set_type_primary_storage_source
        
    case "${2}" in
        new-snap|n)
            if [[ -n ${3} ]] && storageName=${3} test_domain_storage_exists; then
                Print "Error: Cannot use desired new snapshot name '${3}' because it already exists"
                exit 64
            fi
            ;;
        revert-snap|r|Delete-snap|D)
            if [[ -n ${3} ]] && ! storageName=${3} test_domain_storage_exists; then
                Print "Error: Invalid snapshot/storage name '${3}'"
                storageName=${3} remove_stale_lvm_storage_from_config
                echo "Run ${pzero} with no args to see what's available for ${1}"
                exit 64
            fi
    esac
}

main() {
    # Parse the cmdline
    until [[ ${1} == -- ]]; do
        case "${1}" in
            --all|-a)
                shift; allDomains=true ;;
            --off)
                shift; startDomains=false ;;
            -h)
                shift; show_usage +note; exit ;;
            --help)
                shift; show_help | less -R; exit ;;
            --size|-L)
                snapshotDesiredSize=${2}; shift 2 ;;
        esac
    done
    shift  # (to get rid of the '--')
    sanity_check_args "${@}"
    # Make shit happen
    if [[ ${allDomains} == true ]]; then
        # If executed as: "$0 --all {new-snap|revert-snap|start|Shutdown|Hard-reboot|hibernate|destroy}" (with or without --off) ...
        # Then: kick off jobs in pseudo-parallel
        verbose=
        trap cleanup_bg_jobs 2
        for Domain in $(virsh list --all --name); do
            case_thru_args -bg "${@}" &
        done
        wait
        trap 2
    else
        verbose=--verbose
        Domain=${1}
        shift
        # If NOT run with --all/-a:
        case_thru_args -fg "${@}"
    fi
}

# Check for bad '-' or '--' options
getopt -Q --name=${pzero} -o ${sOpts} -l ${lOpts} -- "${@}" || { show_usage +note; exit 64; }

# Main thread
main $(getopt -u --name=${pzero} -o ${sOpts} -l ${lOpts} -- "${@}")
